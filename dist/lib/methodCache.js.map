{"version":3,"file":"methodCache.js","sourceRoot":"","sources":["../../src/lib/methodCache.ts"],"names":[],"mappings":";;;;;AAAA,0DAA2B;AAC3B,+BAA8B;AAIjB,QAAA,OAAO,GAAwC,IAAI,GAAG,EAAE,CAAA;AACxD,QAAA,QAAQ,GAAgB;IACnC,GAAG,EAAE,GAAG;IACR,MAAM,EAAE,GAAG,GAAG,IAAI;CACnB,CAAA;AAED;;;GAGG;AACH,aAAqB,aAAqB;IACxC,gBAAQ,GAAG,aAAa,CAAA;AAC1B,CAAC;AAFD,kBAEC;AAED;;;;;GAKG;AACH,gBAAwB,MAAc,EAAE,UAAuB,EAAE;IAC/D,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAQ,EAAE,OAAO,CAAC,CAAA;IAC1C,eAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,mBAAG,CAAC,OAAO,CAAC,CAAC,CAAA;IACrC,MAAM,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AAC5B,CAAC;AAJD,wBAIC;AAED;;;;GAIG;AACH,cAAsB,MAAc,EAAE,GAAW;IAC/C,EAAE,CAAC,CAAC,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAAC,MAAM,CAAC,MAAM,CAAC,CAAA,CAAC,mBAAmB;IAC5D,MAAM,WAAW,GAAG,eAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAA;IACxC,IAAI,WAAW,CAAA;IAEf,EAAE,CAAC,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QACzB,YAAM,CAAC,KAAK,CAAC,IAAI,MAAM,uBAAuB,GAAG,EAAE,CAAC,CAAA;QACpD,0DAA0D;QAC1D,WAAW,GAAG,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;IACpC,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,kDAAkD;QAClD,YAAM,CAAC,KAAK,CAAC,IAAI,MAAM,wBAAwB,GAAG,EAAE,CAAC,CAAA;QACrD,WAAW,GAAG,gBAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,MAAM,CAAA;QAC/C,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,WAAW,CAAC,CAAA;IACnC,CAAC;IACD,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;AACrC,CAAC;AAhBD,oBAgBC;AAED;;;;GAIG;AACH,aAAqB,MAAc;IACjC,MAAM,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AAC5B,CAAC;AAFD,kBAEC;AAED;;;;GAIG;AACH,aAAqB,MAAc,EAAE,GAAW;IAC9C,EAAE,CAAC,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAAC,MAAM,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AAC/D,CAAC;AAFD,kBAEC;AAED;;;;GAIG;AACH,eAAuB,MAAc,EAAE,GAAY;IACjD,EAAE,CAAC,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QACxB,EAAE,CAAC,CAAC,GAAG,CAAC;YAAC,MAAM,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QAC7C,IAAI;YAAC,MAAM,CAAC,eAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,KAAK,EAAE,CAAA;IAC1C,CAAC;AACH,CAAC;AALD,sBAKC;AAED;;GAEG;AACH;IACE,eAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAA;AAC3C,CAAC;AAFD,4BAEC","sourcesContent":["import LRU from 'lru-cache'\r\nimport { logger } from './log'\r\n\r\n/** @TODO: Remove ! post-fix expression when TypeScript #9619 resolved */\r\nexport let instance: any\r\nexport const results: Map<string, LRU.Cache<string, any>> = new Map()\r\nexport const defaults: LRU.Options = {\r\n  max: 100,\r\n  maxAge: 300 * 1000\r\n}\r\n\r\n/**\r\n * Set the instance to call methods on, with cached results.\r\n * @param instanceToUse Instance of a class\r\n */\r\nexport function use (instanceToUse: object): void {\r\n  instance = instanceToUse\r\n}\r\n\r\n/**\r\n * Setup a cache for a method call.\r\n * @param method Method name, for index of cached results\r\n * @param options.max Maximum size of cache\r\n * @param options.maxAge Maximum age of cache\r\n */\r\nexport function create (method: string, options: LRU.Options = {}): LRU.Cache<string, any> | undefined {\r\n  options = Object.assign(defaults, options)\r\n  results.set(method, new LRU(options))\r\n  return results.get(method)\r\n}\r\n\r\n/**\r\n * Get results of a prior method call or call and cache.\r\n * @param method Method name, to call on instance in use\r\n * @param key Key to pass to method call and save results against\r\n */\r\nexport function call (method: string, key: string): Promise<any> {\r\n  if (!results.has(method)) create(method) // create as needed\r\n  const methodCache = results.get(method)!\r\n  let callResults\r\n\r\n  if (methodCache.has(key)) {\r\n    logger.debug(`[${method}] Calling (cached): ${key}`)\r\n    // return from cache if key has been used on method before\r\n    callResults = methodCache.get(key)\r\n  } else {\r\n    // call and cache for next time, returning results\r\n    logger.debug(`[${method}] Calling (caching): ${key}`)\r\n    callResults = instance.call(method, key).result\r\n    methodCache.set(key, callResults)\r\n  }\r\n  return Promise.resolve(callResults)\r\n}\r\n\r\n/**\r\n * Proxy for checking if method has been cached.\r\n * Cache may exist from manual creation, or prior call.\r\n * @param method Method name for cache to get\r\n */\r\nexport function has (method: string): boolean {\r\n  return results.has(method)\r\n}\r\n\r\n/**\r\n * Get results of a prior method call.\r\n * @param method Method name for cache to get\r\n * @param key Key for method result set to return\r\n */\r\nexport function get (method: string, key: string): LRU.Cache<string, any> | undefined {\r\n  if (results.has(method)) return results.get(method)!.get(key)\r\n}\r\n\r\n/**\r\n * Reset a cached method call's results (all or only for given key).\r\n * @param method Method name for cache to clear\r\n * @param key Key for method result set to clear\r\n */\r\nexport function reset (method: string, key?: string): void {\r\n  if (results.has(method)) {\r\n    if (key) return results.get(method)!.del(key)\r\n    else return results.get(method)!.reset()\r\n  }\r\n}\r\n\r\n/**\r\n * Reset cached results for all methods.\r\n */\r\nexport function resetAll (): void {\r\n  results.forEach((cache) => cache.reset())\r\n}\r\n"]}
{"version":3,"file":"driver.js","sourceRoot":"","sources":["../../src/lib/driver.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events'\r\nimport Asteroid from 'asteroid'\r\nimport * as settings from './settings'\r\nimport * as methodCache from './methodCache'\r\nimport { Message } from './message'\r\nimport {\r\n  IConnectOptions,\r\n  IRespondOptions,\r\n  ICallback,\r\n  ILogger\r\n} from '../config/driverInterfaces'\r\nimport {\r\n  IAsteroid,\r\n  ICredentials,\r\n  ISubscription,\r\n  ICollection\r\n} from '../config/asteroidInterfaces'\r\nimport { IMessage } from '../config/messageInterfaces'\r\nimport { logger, replaceLog } from './log'\r\nimport { IMessageReceiptAPI } from '../utils/interfaces'\r\n\r\n/** Collection names */\r\nconst _messageCollectionName = 'stream-room-messages'\r\nconst _messageStreamName = '__my_messages__'\r\n\r\n// CONNECTION SETUP AND CONFIGURE\r\n// -----------------------------------------------------------------------------\r\n\r\n/** Internal for comparing message update timestamps */\r\nexport let lastReadTime: Date\r\n\r\n/**\r\n * The integration property is applied as an ID on sent messages `bot.i` param\r\n * Should be replaced when connection is invoked by a package using the SDK\r\n * e.g. The Hubot adapter would pass its integration ID with credentials, like:\r\n */\r\nexport const integrationId = settings.integrationId\r\n\r\n/**\r\n * Event Emitter for listening to connection.\r\n * @example\r\n *  import { driver } from '@rocket.chat/sdk'\r\n *  driver.connect()\r\n *  driver.events.on('connected', () => console.log('driver connected'))\r\n */\r\nexport const events = new EventEmitter()\r\n\r\n/**\r\n * An Asteroid instance for interacting with Rocket.Chat.\r\n * Variable not initialised until `connect` called.\r\n */\r\nexport let asteroid: IAsteroid\r\n\r\n/**\r\n * Asteroid subscriptions, exported for direct polling by adapters\r\n * Variable not initialised until `prepMeteorSubscriptions` called.\r\n */\r\nexport let subscriptions: ISubscription[] = []\r\n\r\n/**\r\n * Current user object populated from resolved login\r\n */\r\nexport let userId: string\r\n\r\n/**\r\n * Array of joined room IDs (for reactive queries)\r\n */\r\nexport let joinedIds: string[] = []\r\n\r\n/**\r\n * Array of messages received from reactive collection\r\n */\r\nexport let messages: ICollection\r\n\r\n/**\r\n * Allow override of default logging with adapter's log instance\r\n */\r\nexport function useLog (externalLog: ILogger) {\r\n  replaceLog(externalLog)\r\n}\r\n\r\n/**\r\n * Initialise asteroid instance with given options or defaults.\r\n * Returns promise, resolved with Asteroid instance. Callback follows\r\n * error-first-pattern. Error returned or promise rejected on timeout.\r\n * Removes http/s protocol to get connection hostname if taken from URL.\r\n * @example <caption>Use with callback</caption>\r\n *  import { driver } from '@rocket.chat/sdk'\r\n *  driver.connect({}, (err) => {\r\n *    if (err) throw err\r\n *    else console.log('connected')\r\n *  })\r\n * @example <caption>Using promise</caption>\r\n *  import { driver } from '@rocket.chat/sdk'\r\n *  driver.connect()\r\n *    .then(() => console.log('connected'))\r\n *    .catch((err) => console.error(err))\r\n */\r\nexport function connect (\r\n  options: IConnectOptions = {},\r\n  callback?: ICallback\r\n): Promise<IAsteroid> {\r\n  return new Promise((resolve, reject) => {\r\n    const config = Object.assign({}, settings, options) // override defaults\r\n    config.host = config.host.replace(/(^\\w+:|^)\\/\\//, '')\r\n    logger.info('[connect] Connecting', config)\r\n    asteroid = new Asteroid(config.host, config.useSsl)\r\n\r\n    setupMethodCache(asteroid) // init instance for later caching method calls\r\n    asteroid.on('connected', () => {\r\n      asteroid.resumeLoginPromise.catch(function () {\r\n        // pass\r\n      })\r\n      events.emit('connected')\r\n    })\r\n    asteroid.on('reconnected', () => events.emit('reconnected'))\r\n    let cancelled = false\r\n    const rejectionTimeout = setTimeout(function () {\r\n      logger.info(`[connect] Timeout (${config.timeout})`)\r\n      const err = new Error('Asteroid connection timeout')\r\n      cancelled = true\r\n      events.removeAllListeners('connected')\r\n      callback ? callback(err, asteroid) : reject(err)\r\n    }, config.timeout)\r\n\r\n    // if to avoid condition where timeout happens before listener to 'connected' is added\r\n    // and this listener is not removed (because it was added after the removal)\r\n    if (!cancelled) {\r\n      events.once('connected', () => {\r\n        logger.info('[connect] Connected')\r\n        // if (cancelled) return asteroid.ddp.disconnect() // cancel if already rejected\r\n        clearTimeout(rejectionTimeout)\r\n        if (callback) callback(null, asteroid)\r\n        resolve(asteroid)\r\n      })\r\n    }\r\n  })\r\n}\r\n\r\n/** Remove all active subscriptions, logout and disconnect from Rocket.Chat */\r\nexport function disconnect (): Promise<void> {\r\n  logger.info('Unsubscribing, logging out, disconnecting')\r\n  unsubscribeAll()\r\n  return logout()\r\n    .then(() => Promise.resolve())\r\n}\r\n\r\n// ASYNC AND CACHE METHOD UTILS\r\n// -----------------------------------------------------------------------------\r\n\r\n/**\r\n * Setup method cache configs from env or defaults, before they are called.\r\n * @param asteroid The asteroid instance to cache method calls\r\n */\r\nfunction setupMethodCache (asteroid: IAsteroid): void {\r\n  methodCache.use(asteroid)\r\n  methodCache.create('getRoomIdByNameOrId', {\r\n    max: settings.roomCacheMaxSize,\r\n    maxAge: settings.roomCacheMaxAge\r\n  }),\r\n  methodCache.create('getRoomNameById', {\r\n    max: settings.roomCacheMaxSize,\r\n    maxAge: settings.roomCacheMaxAge\r\n  })\r\n  methodCache.create('createDirectMessage', {\r\n    max: settings.dmCacheMaxSize,\r\n    maxAge: settings.dmCacheMaxAge\r\n  })\r\n}\r\n\r\n/**\r\n * Wraps method calls to ensure they return a Promise with caught exceptions.\r\n * @param method The Rocket.Chat server method, to call through Asteroid\r\n * @param params Single or array of parameters of the method to call\r\n */\r\nexport function asyncCall (method: string, params: any | any[]): Promise<any> {\r\n  if (!Array.isArray(params)) params = [params] // cast to array for apply\r\n  logger.info(`[${method}] Calling (async): ${JSON.stringify(params)}`)\r\n  return Promise.resolve(asteroid.apply(method, params).result)\r\n    .catch((err: Error) => {\r\n      logger.error(`[${method}] Error:`, err)\r\n      throw err // throw after log to stop async chain\r\n    })\r\n    .then((result: any) => {\r\n      (result)\r\n        ? logger.debug(`[${method}] Success: ${JSON.stringify(result)}`)\r\n        : logger.debug(`[${method}] Success`)\r\n      return result\r\n    })\r\n}\r\n\r\n/**\r\n * Call a method as async via Asteroid, or through cache if one is created.\r\n * If the method doesn't have or need parameters, it can't use them for caching\r\n * so it will always call asynchronously.\r\n * @param name The Rocket.Chat server method to call\r\n * @param params Single or array of parameters of the method to call\r\n */\r\nexport function callMethod (name: string, params?: any | any[]): Promise<any> {\r\n  return (methodCache.has(name) || typeof params === 'undefined')\r\n    ? asyncCall(name, params)\r\n    : cacheCall(name, params)\r\n}\r\n\r\n/**\r\n * Wraps Asteroid method calls, passed through method cache if cache is valid.\r\n * @param method The Rocket.Chat server method, to call through Asteroid\r\n * @param key Single string parameters only, required to use as cache key\r\n */\r\nexport function cacheCall (method: string, key: string): Promise<any> {\r\n  return methodCache.call(method, key)\r\n    .catch((err: Error) => {\r\n      logger.error(`[${method}] Error:`, err)\r\n      throw err // throw after log to stop async chain\r\n    })\r\n    .then((result: any) => {\r\n      (result)\r\n        ? logger.debug(`[${method}] Success: ${JSON.stringify(result)}`)\r\n        : logger.debug(`[${method}] Success`)\r\n      return result\r\n    })\r\n}\r\n\r\n// LOGIN AND SUBSCRIBE TO ROOMS\r\n// -----------------------------------------------------------------------------\r\n\r\n/** Login to Rocket.Chat via Asteroid */\r\nexport function login (credentials: ICredentials = {\r\n  username: settings.username,\r\n  password: settings.password,\r\n  ldap: settings.ldap\r\n}): Promise<any> {\r\n  let login: Promise<any>\r\n  // if (credentials.ldap) {\r\n  //   logger.info(`[login] Logging in ${credentials.username} with LDAP`)\r\n  //   login = asteroid.loginWithLDAP(\r\n  //     credentials.email || credentials.username,\r\n  //     credentials.password,\r\n  //     { ldap: true, ldapOptions: credentials.ldapOptions || {} }\r\n  //   )\r\n  // } else {\r\n  logger.info(`[login] Logging in ${credentials.username}`)\r\n  login = asteroid.loginWithPassword(\r\n    credentials.email || credentials.username!,\r\n    credentials.password\r\n  )\r\n  // }\r\n  return login\r\n    .then((loggedInUserId) => {\r\n      userId = loggedInUserId\r\n      return loggedInUserId\r\n    })\r\n    .catch((err: Error) => {\r\n      logger.info('[login] Error:', err)\r\n      throw err // throw after log to stop async chain\r\n    })\r\n}\r\n\r\n/** Logout of Rocket.Chat via Asteroid */\r\nexport function logout (): Promise<void | null> {\r\n  return asteroid.logout()\r\n    .catch((err: Error) => {\r\n      logger.error('[Logout] Error:', err)\r\n      throw err // throw after log to stop async chain\r\n    })\r\n}\r\n\r\n/**\r\n * Subscribe to Meteor subscription\r\n * Resolves with subscription (added to array), with ID property\r\n * @todo - 3rd param of asteroid.subscribe is deprecated in Rocket.Chat?\r\n */\r\nexport function subscribe (\r\n  topic: string,\r\n  roomId: string\r\n): Promise<ISubscription> {\r\n  return new Promise((resolve, reject) => {\r\n    logger.info(`[subscribe] Preparing subscription: ${topic}: ${roomId}`)\r\n    const subscription = asteroid.subscribe(topic, roomId, true)\r\n    subscriptions.push(subscription)\r\n    return subscription.ready\r\n      .then((id) => {\r\n        logger.info(`[subscribe] Stream ready: ${id}`)\r\n        resolve(subscription)\r\n      })\r\n  })\r\n}\r\n\r\n/** Unsubscribe from Meteor subscription */\r\nexport function unsubscribe (subscription: ISubscription): void {\r\n  const index = subscriptions.indexOf(subscription)\r\n  if (index === -1) return\r\n  subscription.stop()\r\n  // asteroid.unsubscribe(subscription.id) // v2\r\n  subscriptions.splice(index, 1) // remove from collection\r\n  logger.info(`[${subscription.id}] Unsubscribed`)\r\n}\r\n\r\n/** Unsubscribe from all subscriptions in collection */\r\nexport function unsubscribeAll (): void {\r\n  subscriptions.map((s: ISubscription) => unsubscribe(s))\r\n}\r\n\r\n/**\r\n * Begin subscription to room events for user.\r\n * Older adapters used an option for this method but it was always the default.\r\n */\r\nexport function subscribeToMessages (): Promise<ISubscription> {\r\n  return subscribe(_messageCollectionName, _messageStreamName)\r\n    .then((subscription) => {\r\n      messages = asteroid.getCollection(_messageCollectionName)\r\n      return subscription\r\n    })\r\n}\r\n\r\n/**\r\n * Once a subscription is created, using `subscribeToMessages` this method\r\n * can be used to attach a callback to changes in the message stream.\r\n * This can be called directly for custom extensions, but for most usage (e.g.\r\n * for bots) the respondToMessages is more useful to only receive messages\r\n * matching configuration.\r\n *\r\n * If the bot hasn't been joined to any rooms at this point, it will attempt to\r\n * join now based on environment config, otherwise it might not receive any\r\n * messages. It doesn't matter that this happens asynchronously because the\r\n * bot's joined rooms can change after the reactive query is set up.\r\n *\r\n * @todo `reactToMessages` should call `subscribeToMessages` if not already\r\n *       done, so it's not required as an arbitrary step for simpler adapters.\r\n *       Also make `login` call `connect` for the same reason, the way\r\n *       `respondToMessages` calls `respondToMessages`, so all that's really\r\n *       required is:\r\n *       `driver.login(credentials).then(() => driver.respondToMessages(callback))`\r\n * @param callback Function called with every change in subscriptions.\r\n *  - Uses error-first callback pattern\r\n *  - Second argument is the changed item\r\n *  - Third argument is additional attributes, such as `roomType`\r\n */\r\nexport function reactToMessages (callback: ICallback): void {\r\n  logger.info(`[reactive] Listening for change events in collection ${messages.name}`)\r\n\r\n  messages.reactiveQuery({}).on('change', (_id: string) => {\r\n    const changedMessageQuery = messages.reactiveQuery({ _id })\r\n    if (changedMessageQuery.result && changedMessageQuery.result.length > 0) {\r\n      const changedMessage = changedMessageQuery.result[0]\r\n      if (Array.isArray(changedMessage.args)) {\r\n        logger.info(`[received] Message in room ${ changedMessage.args[0].rid }`)\r\n        callback(null, changedMessage.args[0], changedMessage.args[1])\r\n      } else {\r\n        logger.debug('[received] Update without message args')\r\n      }\r\n    } else {\r\n      logger.debug('[received] Reactive query at ID ${ _id } without results')\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Proxy for `reactToMessages` with some filtering of messages based on config.\r\n *\r\n * @param callback Function called after filters run on subscription events.\r\n *  - Uses error-first callback pattern\r\n *  - Second argument is the changed item\r\n *  - Third argument is additional attributes, such as `roomType`\r\n * @param options Sets filters for different event/message types.\r\n */\r\nexport function respondToMessages (\r\n  callback: ICallback,\r\n  options: IRespondOptions = {}\r\n): Promise<void | void[]> {\r\n  const config = Object.assign({}, settings, options)\r\n  // return value, may be replaced by async ops\r\n  let promise: Promise<void | void[]> = Promise.resolve()\r\n\r\n  // Join configured rooms if they haven't been already, unless listening to all\r\n  // public rooms, in which case it doesn't matter\r\n  if (\r\n    !config.allPublic &&\r\n    joinedIds.length === 0 &&\r\n    config.rooms &&\r\n    config.rooms.length > 0\r\n  ) {\r\n    promise = joinRooms(config.rooms)\r\n      .catch((err) => {\r\n        logger.error(`[joinRooms] Failed to join configured rooms (${config.rooms.join(', ')}): ${err.message}`)\r\n      })\r\n  }\r\n\r\n  lastReadTime = new Date() // init before any message read\r\n  reactToMessages(async (err, message, meta) => {\r\n    if (err) {\r\n      logger.error(`[received] Unable to receive: ${err.message}`)\r\n      callback(err) // bubble errors back to adapter\r\n    }\r\n\r\n    // Ignore bot's own messages\r\n    if (message.u._id === userId) return\r\n\r\n    // Ignore DMs unless configured not to\r\n    const isDM = meta.roomType === 'd'\r\n    if (isDM && !config.dm) return\r\n\r\n    // Ignore Livechat unless configured not to\r\n    const isLC = meta.roomType === 'l'\r\n    if (isLC && !config.livechat) return\r\n\r\n    // Ignore messages in un-joined public rooms unless configured not to\r\n    if (!config.allPublic && !isDM && !meta.roomParticipant) return\r\n\r\n    // Set current time for comparison to incoming\r\n    let currentReadTime = new Date(message.ts.$date)\r\n\r\n    // Ignore edited messages if configured to\r\n    if (!config.edited && message.editedAt) return\r\n\r\n    // Set read time as time of edit, if message is edited\r\n    if (message.editedAt) currentReadTime = new Date(message.editedAt.$date)\r\n\r\n    // Ignore messages in stream that aren't new\r\n    if (currentReadTime <= lastReadTime) return\r\n\r\n    // At this point, message has passed checks and can be responded to\r\n    logger.info(`[received] Message ${message._id} from ${message.u.username}`)\r\n    lastReadTime = currentReadTime\r\n\r\n    // Processing completed, call callback to respond to message\r\n    callback(null, message, meta)\r\n  })\r\n  return promise\r\n}\r\n\r\n// PREPARE AND SEND MESSAGES\r\n// -----------------------------------------------------------------------------\r\n\r\n/** Get ID for a room by name (or ID). */\r\nexport function getRoomId (name: string): Promise<string> {\r\n  return cacheCall('getRoomIdByNameOrId', name)\r\n}\r\n\r\n/** Get name for a room by ID. */\r\nexport function getRoomName (id: string): Promise<string> {\r\n  return cacheCall('getRoomNameById', id)\r\n}\r\n\r\n/**\r\n * Get ID for a DM room by its recipient's name.\r\n * Will create a DM (with the bot) if it doesn't exist already.\r\n * @todo test why create resolves with object instead of simply ID\r\n */\r\nexport function getDirectMessageRoomId (username: string): Promise<string> {\r\n  return cacheCall('createDirectMessage', username)\r\n    .then((DM) => DM.rid)\r\n}\r\n\r\n/** Join the bot into a room by its name or ID */\r\nexport async function joinRoom (room: string): Promise<void> {\r\n  let roomId = await getRoomId(room)\r\n  let joinedIndex = joinedIds.indexOf(room)\r\n  if (joinedIndex !== -1) {\r\n    logger.error(`[joinRoom] room was already joined`)\r\n  } else {\r\n    await asyncCall('joinRoom', roomId)\r\n    joinedIds.push(roomId)\r\n  }\r\n}\r\n\r\n/** Exit a room the bot has joined */\r\nexport async function leaveRoom (room: string): Promise<void> {\r\n  let roomId = await getRoomId(room)\r\n  let joinedIndex = joinedIds.indexOf(room)\r\n  if (joinedIndex === -1) {\r\n    logger.error(`[leaveRoom] failed because bot has not joined ${room}`)\r\n  } else {\r\n    await asyncCall('leaveRoom', roomId)\r\n    delete joinedIds[joinedIndex]\r\n  }\r\n}\r\n\r\n/** Join a set of rooms by array of names or IDs */\r\nexport function joinRooms (rooms: string[]): Promise<void[]> {\r\n  return Promise.all(rooms.map((room) => joinRoom(room)))\r\n}\r\n\r\n/**\r\n * Structure message content, optionally addressing to room ID.\r\n * Accepts message text string or a structured message object.\r\n */\r\nexport function prepareMessage (\r\n  content: string | IMessage,\r\n  roomId?: string\r\n): Message {\r\n  const message = new Message(content, integrationId)\r\n  if (roomId) message.setRoomId(roomId)\r\n  return message\r\n}\r\n\r\n/**\r\n * Send a prepared message object (with pre-defined room ID).\r\n * Usually prepared and called by sendMessageByRoomId or sendMessageByRoom.\r\n */\r\nexport function sendMessage (message: IMessage): Promise<IMessageReceiptAPI> {\r\n  return asyncCall('sendMessage', message)\r\n}\r\n\r\n/**\r\n * Prepare and send string/s to specified room ID.\r\n * @param content Accepts message text string or array of strings.\r\n * @param roomId  ID of the target room to use in send.\r\n * @todo Returning one or many gets complicated with type checking not allowing\r\n *       use of a property because result may be array, when you know it's not.\r\n *       Solution would probably be to always return an array, even for single\r\n *       send. This would be a breaking change, should hold until major version.\r\n */\r\nexport function sendToRoomId (\r\n  content: string | string[] | IMessage,\r\n  roomId: string\r\n): Promise<IMessageReceiptAPI[] | IMessageReceiptAPI> {\r\n  if (!Array.isArray(content)) {\r\n    return sendMessage(prepareMessage(content, roomId))\r\n  } else {\r\n    return Promise.all(content.map((text) => {\r\n      return sendMessage(prepareMessage(text, roomId))\r\n    }))\r\n  }\r\n}\r\n\r\n/**\r\n * Prepare and send string/s to specified room name (or ID).\r\n * @param content Accepts message text string or array of strings.\r\n * @param room    A name (or ID) to resolve as ID to use in send.\r\n */\r\nexport function sendToRoom (\r\n  content: string | string[] | IMessage,\r\n  room: string\r\n): Promise<IMessageReceiptAPI[] | IMessageReceiptAPI> {\r\n  return getRoomId(room)\r\n    .then((roomId) => sendToRoomId(content, roomId))\r\n}\r\n\r\n/**\r\n * Prepare and send string/s to a user in a DM.\r\n * @param content   Accepts message text string or array of strings.\r\n * @param username  Name to create (or get) DM for room ID to use in send.\r\n */\r\nexport function sendDirectToUser (\r\n  content: string | string[] | IMessage,\r\n  username: string\r\n): Promise<IMessageReceiptAPI[] | IMessageReceiptAPI> {\r\n  return getDirectMessageRoomId(username)\r\n    .then((rid) => sendToRoomId(content, rid))\r\n}\r\n\r\n/**\r\n * Edit an existing message, replacing any attributes with those provided.\r\n * The given message object should have the ID of an existing message.\r\n */\r\nexport function editMessage (message: IMessage): Promise<IMessage> {\r\n  return asyncCall('updateMessage', message)\r\n}\r\n\r\n/**\r\n * Send a reaction to an existing message. Simple proxy for method call.\r\n * @param emoji     Accepts string like `:thumbsup:` to add 👍 reaction\r\n * @param messageId ID for a previously sent message\r\n */\r\nexport function setReaction (emoji: string, messageId: string) {\r\n  return asyncCall('setReaction', [emoji, messageId])\r\n}\r\n"]}